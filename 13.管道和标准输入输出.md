#### 输入设备/输出设备
* ###### 程序:     指令和数据
* ###### 控制器:   指令
* ###### 运算器:
* ###### 存储器:
* ###### 地址总线: 内存寻址
* ###### 数据总线: 传输数据
* ###### 控制总线: 控制指令

<br>

#### 系统设定
* ###### 默认输出设备: 标准输出,stdout,1
* ###### 默认输入设备: 标准输入,stdin,0
* ###### 标准输入: 键盘
* ###### 标准输出和错误输出: 显示器

```shell
I/O 重定向：

Linux：
>
<
```

bash 有很多内建命令: set -c 禁止对已经存在文件使用覆盖重定向, 强制覆盖删除，则使用  >|

set +c      关闭上述功能

ls /usr > | /tmp/var.out        

2>：     重定向错误输出

2>>：  重定向追加错误输出， 追加方式

ls /varrr   >  /tmp/var3.out   2> /tmp/err.out

&>：     重定向标准输出

cat /etc/fstab | tr 'a-z' 'A-Z‘

```shell
root@ansible:~# cat << END
> The first line.
> The second line.
> END
The first line.
The second line.
```


管道： 前一个命令的删除，作为后一个命令的输入

命令1  |  命令2  |  命令3

```shell
root@ansible:~# echo "hello world" |  tr 'a-z' 'A-Z'
HELLO WORLD
```

环境中支持输入输出重定向，用符号<和>来表示。0、1和2分别表示标准输入、标准输出和标准错误信息输出，可以用来指定需要重定向的标准输入或输出，比如 2>a.txt 表示将错误信息输出到文件a.txt中。

同时，还可以在这三个标准输入输出之间实现重定向，比如将错误信息重定向到标准输出，可以用 2>&1来实现。

Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到/dev/null。

如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到/dev/null， 例如：

```shell
ls 1>/dev/null 2>/dev/null
```

还有一种做法是将错误重定向到标准输出，然后再重定向到 /dev/null，例如：

```shell
ls >/dev/null 2>&1
```
注意: 此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，于是一切静悄悄:-)
另外+: $make >& filename.log &   意思是把标准输出和错误输出都重定向, make>out 只重定向标准输出
* ###### >log 表示把标准输出重新定向到文件log中
* ###### >& log 表示把标准输出和错误输出都定向到文件log中，相当于 >log 2>&1

