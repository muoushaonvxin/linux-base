
#### 文本查找的需要
grep    egrep   fgrep

* pattern：文本字符和正则表达式的元字符组合而成的匹配条件。
* grep：根据模式，搜索文本，并将符合模式的文本行显示出来


#### grep [option] [pattern] [file...]
* -i: 不区分大小写
* --color: 颜色
* -v：显示没有被模式匹配到的行
* -o：表示只显示被模式匹配到的字符串
        
* *：任意长度的任意字符
* ?：任意单个字符
* []：
* [^]：
* . ：表示匹配任意单个字符        


#### 匹配次数（正则表达式默认工作在贪婪模式下）
#### 字符个数的元字符
> *：匹配其前面的字符任意次        
> a, b, ab, aab, acb, adb, amnb
> a*b
> a.*b
        
#### .*：任意长度的任意字符


#### \?：匹配其前面的字符1次或0次
>\{m,n\}：匹配其前的字符至少m次至多n次
        \{1,\}
        \{0,3\}


#### 位置锚订：        
* ^：锚定行首，次字符后面的字符串后面的任意内容必须出现在行首
* $：锚定行位，字符后面的字符匹配
* ^$：表示空白行
        字符集合：[:digit:]  [:lower:]  [:upper:]  [:punct:]  [:space:] [:alpha:] [:alnum:]
    
grep '[[:digit:]]$' /etc/inittab

#### 匹配一个或多个空白字符结尾的行
> grep '[[:space:]][[:digit:]]$' /etc/inittab

#### 锚定单词首部
> \<或者 \b：其后面的任意字符必须作为单词首部出现
> \>或者 \b：表示其前面的任意字符必须作为单词的尾部出现

> \<root\>   锚定一个单词

> grep "\<root"  /root/test.txt

> grep "root\>" /root/test.txt

> grep "\<root\>" /root/test.txt

> grep "\(ab\)*" /root/test.txt

#### \（\）
* \1：第一个左括号以及与之对应的右括号所包括的字符
* \2
* \3
        

#### 怎么实现后像引用

```shell
cat test.tct && grep '\(l..e\).*\1' test.tct 
He love his lover.
She like her lover.
He like his liker.
She love her liker.
He love his lover.
He like his liker.
```




        
正则表达式：Regular EXPression， REGEXP

#### 扩展正则表达式
* *：
* \?：
* \{m,n\}：

grep：默认情况下只使用基本的正则表达式模式来过滤文本


-E：使用扩展的正则表达式
-A #： cat /proc/cpuinfo | grep -A 2 '^vendor_id'        表达匹配到后同时显示后面两行
vendor_id	: GenuineIntel
cpu family	: 6
model		: 58
-B：前面的两行
-C：表示上下都两行


扩展正则表达式
字符匹配

.
[]      指定范围内的单个字符
[^]         指定范围外面的单个字符


次数匹配
*：  其前面的字符0次或者一次
？：
+：  表示匹配其前面的字符至少一次
{m,n}：      扩展正则表达式的花括号不需要加反斜线

位置锚定：
^
$
\<
\>

分组：
（）：分组
\1  \2  \3  .....
   
或者
a|b： 表示or的意思

C|cat：   Cat 或者cat， C或cat
   